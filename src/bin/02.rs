use std::str::FromStr;

#[derive(Debug, PartialEq)]
enum Move {
    Rock,
    Paper,
    Scissors,
}

#[derive(Debug, PartialEq)]
struct InitialMove {
    value: Move,
}

#[derive(Debug, PartialEq)]
struct ResponseMove {
    value: Move,
}

impl ResponseMove {
    fn selection_score(&self) -> usize {
        match self.value {
            Move::Rock => 1,
            Move::Paper => 2,
            Move::Scissors => 3,
        }
    }
    fn game_score(&self, initial: &InitialMove) -> usize {
        match (&self.value, &initial.value) {
            // Draws
            (Move::Rock, Move::Rock) => 3,
            (Move::Paper, Move::Paper) => 3,
            (Move::Scissors, Move::Scissors) => 3,
            // Wins
            (Move::Rock, Move::Scissors) => 6,
            (Move::Scissors, Move::Paper) => 6,
            (Move::Paper, Move::Rock) => 6,
            // Losses
            (Move::Rock, Move::Paper) => 0,
            (Move::Scissors, Move::Rock) => 0,
            (Move::Paper, Move::Scissors) => 0,
        }
    }
    fn total_score(&self, initial: &InitialMove) -> usize {
        self.selection_score() + self.game_score(initial)
    }
}

impl FromStr for InitialMove {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let value = match s {
            "A" => Move::Rock,
            "B" => Move::Paper,
            "C" => Move::Scissors,
            _ => panic!("Invalid move"),
        };

        Ok(InitialMove { value: value })
    }
}

impl FromStr for ResponseMove {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let value = match s {
            "X" => Move::Rock,
            "Y" => Move::Paper,
            "Z" => Move::Scissors,
            _ => panic!("Invalid move"),
        };

        Ok(ResponseMove { value: value })
    }
}

fn parse_input(input: &str) -> Vec<(InitialMove, ResponseMove)> {
    // This was entirely generated by Copilot on the first try after I had implemented the above types
    let mut moves = Vec::new();
    for line in input.lines() {
        let mut parts = line.split_whitespace();
        let initial_move = parts.next().unwrap().parse::<InitialMove>().unwrap();
        let response_move = parts.next().unwrap().parse::<ResponseMove>().unwrap();
        moves.push((initial_move, response_move));
    }
    moves
}

pub fn part_one(input: &str) -> Option<u32> {
    // First submission: "That's not the right answer; your answer is too high." `13796`
    // Average score should be (2 + 3) * 2500 = 12500, so it's in the right ballpark
    // Realized that I flipped around which thing gets scored: ResponseMove should be scored, not InitialMove
    let moves = parse_input(input);
    let mut score = 0;
    for (initial_move, response_move) in moves {
        score += response_move.total_score(&initial_move) as u32;
    }
    Some(score)
}

pub fn part_two(input: &str) -> Option<u32> {
    None
}

fn main() {
    let input = &advent_of_code::read_file("inputs", 2);
    advent_of_code::solve!(1, part_one, input);
    advent_of_code::solve!(2, part_two, input);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_part_one() {
        let input = advent_of_code::read_file("examples", 2);
        assert_eq!(part_one(&input), Some(15));
    }

    #[test]
    fn test_part_two() {
        let input = advent_of_code::read_file("examples", 2);
        assert_eq!(part_two(&input), None);
    }
}
